<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>LCI — Set Booster EV</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html{background-color:#0b0d10}
  /* All styles scoped under .eoe-app for portability (copied from your template) */
  .eoe-app{
    --bg:#0b0d10; --fg:#e8ecf1; --muted:#a7b0bb; --acc:#6ac1ff;
    --card:#151a20; --line:#222a33; --ok:#1e7f3c; --warn:#9b2c2c;
    --hi-bg:rgba(106,193,255,.14); --hi-line:#6ac1ff;
    --est-bg:rgba(106,193,255,.18); --est-line:#6ac1ff;
    max-width:1120px; margin:32px auto; padding:0 16px; box-sizing:border-box;
    color:var(--fg); background:var(--bg); font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .eoe-app a{ color:var(--acc); text-decoration:underline }
  .eoe-app h1{font-size:22px;margin:0 0 12px}
  .eoe-app p.lede{color:var(--muted);margin:0 0 16px}
  .panel{background:var(--card); border:1px solid #2a3541; border-radius:10px; padding:16px; margin:16px 0}
  .row{display:flex; flex-wrap:wrap; gap:12px; align-items:center}
  label{display:flex; gap:6px; align-items:center}
  input[type="number"], input[type="text"], select{
    background:#0e1216; color:#cfe3f5; border:1px solid #2a3541; border-radius:6px; padding:6px;
  }
  button{appearance:none;border:1px solid #2c3845;background:#1b232c;color:var(--fg);padding:10px 14px;border-radius:8px;cursor:pointer}
  button[disabled]{opacity:.55;cursor:default}
  .btn-primary{
    border-color:var(--hi-line); background:linear-gradient(180deg,#203245,#1a2530);
    color:#dff1ff; font-weight:600; position:relative;
  }
  .hi-inline{display:flex;align-items:center;gap:6px;border:1px solid var(--hi-line);background:var(--hi-bg);border-radius:8px;padding:6px 8px}
  .hi-label{border:1px solid var(--hi-line);background:var(--hi-bg);border-radius:8px;padding:6px 8px}

  /* Banner header/footer */
  .freBanner{display:flex;justify-content:center;margin:8px 0 16px}
  .freBanner img{max-width:420px;width:100%;height:auto;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  @media (max-width:640px){ .freBanner img{max-width:300px} }

  /* Vertical single‑row checkboxes */
  .vert-list{margin-top:8px; display:flex; flex-direction:column; gap:8px}
  .vert-list label{display:flex; align-items:center; gap:8px; margin:0}

  /* Tables */
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid #2a3541;padding:6px 8px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  thead th{background:#0e1216;position:sticky;top:0;z-index:1}
  tbody tr:nth-child(even){background:#12171d}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3541}
  .pill.ok{background:rgba(30,127,60,.20);color:#d9ffe3;border-color:#1e7f3c}
  .pill.bad{background:rgba(155,44,44,.16);color:#ffdede;border-color:#9b2c2c}
  .sift-ok{background:rgba(30,127,60,.12)!important}
  .sift-bad{background:rgba(155,44,44,.10)!important}

  /* Highlight the Est. column + its left border */
  .evbox table th:nth-child(3),
  .evbox table td:nth-child(3){
    background:var(--est-bg);
    border-color:var(--est-line);
    border-left-color:var(--est-line);
    color:#eaf6ff;
    font-weight:700;
  }
  .evbox table th:nth-child(2),
  .evbox table td:nth-child(2){border-right-color:var(--est-line)}

  /* Collapsible totals */
  details.eoe-collapse>summary{
    cursor:pointer;list-style:none;display:flex;justify-content:space-between;align-items:center;
    padding:8px 10px;border:1px solid #2a3541;border-radius:8px;background:#0e1216;color:#dfeeff;font-weight:600
  }
  details.eoe-collapse>summary::-webkit-details-marker{display:none}
  details.eoe-collapse>summary::after{content:'▼';opacity:.8;transform:rotate(-90deg);transition:transform .18s;margin-left:12px;font-size:12px}
  details.eoe-collapse[open]>summary::after{transform:rotate(0deg)}
  details.eoe-collapse .content{margin-top:10px}
  .note{color:#a7b0bb;font-size:12px;margin-top:6px}
</style>
</head>
<body>
<main class="eoe-app" role="main" aria-label="LCI — Set Booster EV">
  <!-- Banner header (links home) -->
  <div class="freBanner">
    <a href="./index.html"><img src="freEV-banner.png" alt="FreEV — Spend your money on cards not calculators"></a>
  </div>

  <h1>The Lost Caverns of Ixalan — Set Booster EV</h1>
  <p style="color:red;">Looking for ideas and insights on why boxes that include The List vary wildly between different calculators</p>
  <p class="lede">
    Builds on load using Scryfall. Playing‑card odds are normalized to exactly
    <strong>12 Magic cards per pack</strong>. Non‑game content is modeled separately:
    <strong>Art card in every pack</strong>, and the final slot is <strong>Token/Ad (≈75%) or The List (≈25%)</strong>.
    Boxes are assumed to have <strong>30 packs</strong> and include <strong>1 non‑foil Treasure Trove box topper</strong>.
  </p>

  <div class="panel">
    <strong>Refresh data</strong>
    <div class="vert-list">
      <label><input type="checkbox" id="englishOnly" checked> English‑only</label>
      <label><input type="checkbox" id="includeLCI" checked> Include <strong>LCI</strong> (main set, is:booster)</label>
      <label><input type="checkbox" id="includeREX" checked> Include <strong>REX</strong> (Jurassic World — ~1 in 12 Set Boosters)</label>
      <label><input type="checkbox" id="includeTopper" checked> Include <strong>LCC Treasure Trove Box Topper</strong> (1 per display)</label>
      <label><input type="checkbox" id="includeSPG" checked> Include <strong>SPG</strong> (Special Guests — nonfoil in List slot)</label>
    </div>

    <div class="row" style="margin-top:6px">
      <label class="row" style="gap:10px; align-items:center">
        <span style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="includePLST">
          <span>Include <strong>PLST</strong> (The List — LCI edition)*</span>
        </span>
        <span class="note">*Pulls Scryfall’s PLST; keep off if you prefer SPG‑only modeling of the List slot.</span>
      </label>
	  
    </div>

    <div class="row" style="margin-top:6px">
      <label>List slot rate: <input type="text" id="listRate" value="0.25" size="6" title="Per‑pack probability that the final slot is a List card (default 0.25)"></label>
      <label>SPG share of List slot: <input type="text" id="spgShare" value="0.10" size="6" title="Fraction of List cards that are SPG (default 0.10 ≈ 18/(~180+18))"></label>
    </div>

    <div class="row" style="margin-top:6px">
      <label><input type="checkbox" id="includeTOK"> Include <strong>TLCI</strong> tokens (final slot share; unchecked by default)</label>
      <label>Token fallback (USD): <input type="text" id="tokenFallback" value="0.05" size="6"></label>
      <label>Token pool size: <input type="number" id="tokenPool" value="20" min="1" step="1" style="width:8ch"></label>
    </div>

    <div class="row" style="margin-top:6px">
      <label><input type="checkbox" id="includeART"> Include <strong>ALCI</strong> art (normal + signed; unchecked by default)</label>
      <label>Art fallback (USD): <input type="text" id="artFallback" value="0.00" size="6"></label>
    </div>

    <div class="row" style="margin-top:6px">
      <span class="note">Tokens/ad use (1 − listRate). SPG and PLST split the List rate by share.</span>
    </div>

    <div class="row" style="margin-top:6px;display:none">
      <label><input type="checkbox" id="englishREXonly" checked> REX nonfoil only (Set Boosters)</label>
    </div>

    <div class="row actions">
      <button id="buildBtn" class="btn-primary" title="Fetch live Scryfall data and recompute everything">Refresh List</button>
      <button id="downloadCsv" disabled>Download CSV</button>
      <button id="copyCsv" disabled>Copy CSV</button>
    </div>
    <div id="status" class="note" aria-live="polite">Preparing…</div>
    <div id="counts" class="note"></div>
  </div>

  <!-- Purchase EV -->
  <div id="purchasePanel" class="panel" style="display:none">
    <strong>Purchase EV Calculator</strong>
    <div class="row" style="margin-top:6px">
      <label class="hi-label">Boxes to buy: <input type="number" id="boxesToBuy" value="1" min="0" step="1" style="width:10ch"></label>
      <span class="hi-inline" title="Only count prints with card value ≥ this amount">
        <input type="checkbox" id="useSiftForEV" checked>
        <span><strong>Use Sift (≥)</strong></span>
        <input type="text" id="siftMin" value="0.25" style="width:8ch">
      </span>
    </div>
    <div class="row" style="margin-top:6px">
      <label><input type="radio" name="rangeMode" value="stat" checked> Statistical range (CLT)</label>
      <label><input type="radio" name="rangeMode" value="struct"> Structural range (slot band)</label>
      <label>Confidence:
        <select id="confLevel">
          <option value="68">68% (~1σ)</option>
          <option value="90">90% (~1.645σ)</option>
          <option value="95" selected>95% (~1.96σ)</option>
          <option value="99">99% (~2.576σ)</option>
        </select>
      </label>
      <button id="calcEV" disabled>Calculate EV</button>
    </div>
    <div id="purchaseSummary" class="note"></div>
    <div id="purchaseEVContainer" class="evbox" style="display:none"></div>
    <div id="rangeNotes" class="note"></div>
  </div>

  <!-- Sift table -->
  <div id="siftPanel" class="panel" style="display:none">
    <strong>Row List (linked) — highlight by Sift threshold</strong>
    <div class="row">
      <span class="pill ok">≥ threshold</span>
      <span class="pill bad">&lt; threshold</span>
      <button id="applySift" disabled>Re‑Apply Sift</button>
      <button id="downloadSiftCsv" disabled>Download Sift Table</button>
    </div>
    <div id="siftSummary" class="note" aria-live="polite"></div>
    <div class="sift-tablewrap" id="siftTableWrap" style="display:none">
      <table id="siftTable">
        <thead>
          <tr>
            <th>Set</th><th>No.</th><th>R</th><th>Name</th><th>Treat</th>
            <th>Pack Prob Min (%)</th><th>Pack Prob Max (%)</th><th>Card Value (USD)</th>
            <th>Per 1000 Min</th><th>Per 1000 Max</th>
            <th>Per 30000 Min</th><th>Per 30000 Max</th>
            <th>Per 300000 Min</th><th>Per 300000 Max</th>
          </tr>
        </thead>
        <tbody id="siftBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Error (non‑blocking; continues with any sets that loaded) -->
  <div id="errorBox" class="panel" style="display:none; border-color:#ff7a7a">
    <h2 style="color:#ff9a9a;margin:0 0 8px">Some sets failed to load</h2>
    <div id="errorMsg" class="note"></div>
    <pre id="errorDetails" style="white-space:pre-wrap;background:#0e1216;border:1px solid #2a3541;padding:8px;border-radius:6px;color:#ffd4d4"></pre>
  </div>

  <div class="panel">
    <strong>CSV preview</strong>
    <textarea id="preview" placeholder="Your CSV will appear after the list builds…" style="width:100%;min-height:220px;background:#0e1216;color:#cfe3f5;border:1px solid #2a3541;border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;"></textarea>
    <details>
      <summary>Advanced: Scryfall queries</summary>
      <pre id="queries" style="white-space:pre-wrap"></pre>
    </details>
  </div>

  <!-- Totals (collapsible; default closed; no-sift) -->
  <div id="totalsPanel" class="panel" style="display:none">
    <details id="totalsDetails" class="eoe-collapse">
      <summary><strong>Totals for Your Purchase Size (No sift, Developer Model check)</strong></summary>
      <div class="content">
        <div class="note">
          Columns show <em>Low / Est. / High</em>. Totals <b>ignore Sift</b> and include token/art values via fallbacks when missing.
          Playing‑card probabilities are normalized so EST sums to 12 per pack; non‑game items: Art (100%) and final slot mix by List rate.
        </div>
        <table>
          <thead><tr><th>Metric</th><th>Low</th><th>Est.</th><th>High</th></tr></thead>
          <tbody id="totalsBody"></tbody>
        </table>
        <div id="totalsNotes" class="note"></div>
      </div>
    </details>
  </div>

  <!-- Banner footer (links home) -->
  <div class="freBanner">
    <a href="./index.html"><img src="freEV-banner.png" alt="FreEV — Spend your money on cards not calculators"></a>
  </div>
</main>

<!-- Google tag (gtag.js) — placed BEFORE the first custom script -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LWMRXKNY5X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-LWMRXKNY5X');
</script>

<script>
/* ========= Helpers (from template) ========= */
const rarityLetter = r => ({ common:'C', uncommon:'U', rare:'R', mythic:'M' }[r] || (r ? r[0].toUpperCase() : ''));
const sleep = ms => new Promise(res => setTimeout(res, ms));
const padCollector = s => { const m=String(s||'').match(/^(\d+)(.*)$/); return m?m[1].padStart(4,'0')+(m[2]||''):(s||''); };
const baseCN = s => { const m=String(s||'').match(/^(\d+)/); return m?parseInt(m[1],10):NaN; };
const parseUSD = s => { if(s==null) return null; const n=parseFloat(String(s).replace(/[^0-9.]/g,'')); return Number.isFinite(n)?n:null; };
const money = n => Number.isFinite(n)? n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}) : '';
const fmtUSD = n => money(n);
const fmtCount = n => !Number.isFinite(n)? '' : (Math.abs(n-Math.round(n))<1e-9? String(Math.round(n)) : (n>=100?n.toFixed(1):n>=10?n.toFixed(2):n.toFixed(3)));
const fmtInt = n => Number.isFinite(n)? Math.round(n).toLocaleString() : '';
const zFromConf = c => { c=Math.round(c); if(c>=99)return 2.576; if(c>=95)return 1.96; if(c>=90)return 1.645; if(c>=68)return 1.0; return 1.96; };
const priceUSD = (card,treat) => { const p=(treat==='foil'?card?.prices?.usd_foil:card?.prices?.usd); const f=parseFloat(p); return Number.isFinite(f)?f:null; };

/* ========= Pack/odds model (LCI Set Booster) =========
   - Set Booster: normalize playing cards to exactly 12 per pack (EST).
   - Always: 1 Art card; 1 final slot = Token/Ad (~1 - listRate) or The List (~listRate).
   - Rare slot: ~87.5% Rare / 12.5% Mythic.
   - Foil slot (1 per pack) rarity split heuristic: 0.60C / 0.30U / 0.085R / 0.015M (sums 1.0).
   - Wildcards (2) modeled as small extra shares to R/M; remainder folded into C/U shares heuristically.
   - REX (Jurassic World): ~1 in 12 packs (nonfoil only) distributed evenly across its prints.
*/
const PACKS_PER_BOX = 30;
const ODDS = {
  E_COMMON_SLOTS: 5.5,  // heuristic baseline commons share (pre-normalization)
  E_UNCOMMON_SLOTS: 3.5, // heuristic baseline uncommons share (pre-normalization)
  WILD_RARE: 0.18, WILD_MYTHIC: 0.04, // extra rare/mythic from wildcard slots (pre-normalization)
  RM_RARE: 0.875, RM_MYTHIC: 0.125,   // guaranteed rare slot
  FOIL_C: 0.60, FOIL_U: 0.30, FOIL_R: 0.085, FOIL_M: 0.015,
  ART_NORMAL: 0.90, ART_SIGNED: 0.10  // art card split (signed ~1 in 10)
};

// Final slot controls (user adjustable)
function getListControls(){
  const lr = Math.max(0, Math.min(1, parseFloat(document.getElementById('listRate').value)||0));
  const spg = Math.max(0, Math.min(1, parseFloat(document.getElementById('spgShare').value)||0));
  const spgShare = Math.min(spg,1);
  const plstShare = Math.max(0, 1 - spgShare);
  return { listRate: lr, spgShare, plstShare, tokenRate: Math.max(0, 1 - lr) };
}

/* ========= Data state ========= */
let __NORM_SCALE__ = 1;
let __TOKEN_POOL__ = 20;
let __ART_POOL__ = 1;
let __ROW_MODELS__ = []; // { model, price, isNonGame, fallback }
let __META_ROWS__  = []; // { setTag, cn, rarity, name, treatment, model, price, isNonGame, url }
let __SIFT_CSV__   = '';
let __ERRORS__     = [];
let __TOPPER_EST__ = 0;  // expected EV per display from topper

/* ========= Probability models per print ========= */
const PM = {
  point: p => ({ type:'point', p }),
  range: (lo,hi) => ({ type:'range', lo, hi }),
  max: max => ({ type:'max', max })
};
function countFromModelRaw(model, packs){
  if(!model) return null;
  if(model.type==='point') return { lo:model.p*packs, est:model.p*packs, hi:model.p*packs, max:model.p*packs };
  if(model.type==='range') return { lo:model.lo*packs, est:((model.lo+model.hi)/2)*packs, hi:model.hi*packs, max:model.hi*packs };
  if(model.type==='max')   return { lo:0, est:(model.max/2)*packs, hi:model.max*packs, max:model.max*packs };
  return null;
}
function probMinMaxRaw(model){
  if(!model) return {min:null,max:null};
  if(model.type==='point') return {min:model.p,max:model.p};
  if(model.type==='range') return {min:model.lo,max:model.hi};
  if(model.type==='max')   return {min:0,max:model.max};
  return {min:null,max:null};
}
function countFromModel(model, packs, isNonGame=false){
  const c=countFromModelRaw(model,packs); if(!c) return c;
  return isNonGame ? c : { lo:c.lo*__NORM_SCALE__, est:c.est*__NORM_SCALE__, hi:c.hi*__NORM_SCALE__, max:c.max*__NORM_SCALE__ };
}
function probPoint(model){
  if(!model) return null;
  if(model.type==='point') return model.p;
  if(model.type==='range') return (model.lo+model.hi)/2;
  if(model.type==='max')   return model.max/2;
  return null;
}
function probMinMaxScaled(model,isNonGame=false){
  const {min,max}=probMinMaxRaw(model);
  if(min==null) return {min,max};
  return isNonGame? {min,max} : {min:min*__NORM_SCALE__, max:max*__NORM_SCALE__};
}

/* ========= Scryfall I/O ========= */
function buildQuery(which, englishOnly){
  let q='';
  if(which==='LCI')  q='e:lci is:booster -finish:glossy -finish:etched -finish:textured';
  if(which==='REX')  q='e:rex'; // nonfoil enforced at row build
  if(which==='SPG')  q='e:spg'; // nonfoil enforced at row build (List slot)
  if(which==='PLST') q='e:plst'; // caution: entire PLST; see UI note
  if(which==='TLCI') q='e:tlci (layout:token or layout:double_faced_token or layout:emblem)';
  if(which==='ALCI') q='e:alci';
  if(which==='TOPPER') q='e:lcc is:boxtopper';
  if(englishOnly) q+=' lang:en';
  return q;
}
async function fetchAllPagesNonBlocking(q, setLabel, statusEl){
  const base='https://api.scryfall.com/cards/search?unique=prints&order=set&dir=asc&q=';
  let url=base+encodeURIComponent(q), out=[], page=1;
  try{
    while(url){
      statusEl.textContent=`Fetching ${setLabel}: page ${page}…`;
      const resp=await fetch(url);
      if(!resp.ok){
        const txt=await resp.text().catch(()=> '');
        __ERRORS__.push({set:setLabel,query:q,status:resp.status,details:txt});
        break;
      }
      const json=await resp.json();
      out = out.concat(json.data||[]);
      url = json.has_more ? json.next_page : null;
      page++; if(url) await sleep(120);
    }
  }catch(e){
    __ERRORS__.push({set:setLabel,query:q,status:'NETWORK',details:e?.message||String(e)});
  }
  return out;
}

/* ========= Row building ========= */
function pushRow(card, setTag, treatment, model, price, isNonGame=false, fallback=false){
  const cn = padCollector(card.collector_number);
  const rarity = card.rarity ? rarityLetter(card.rarity) : 'C';
  const name = card.name;
  const url  = card.scryfall_uri || '';
  __META_ROWS__.push({ setTag, cn, rarity, name, treatment, model, price, isNonGame, url });
  __ROW_MODELS__.push({ model, price, isNonGame, fallback });
}

function rowsFromLCI(cards){
  const paper = cards.filter(c=> (c.games||[]).includes('paper'));
  const commons  = paper.filter(c=>c.rarity==='common'  && !(c.layout||'').includes('token'));
  const uncommons= paper.filter(c=>c.rarity==='uncommon'&& !(c.layout||'').includes('token'));
  const rares    = paper.filter(c=>c.rarity==='rare');
  const mythics  = paper.filter(c=>c.rarity==='mythic');

  const nC=Math.max(1,commons.length), nU=Math.max(1,uncommons.length), nR=Math.max(1,rares.length), nM=Math.max(1,mythics.length);

  for(const c of paper){
    const finishes=Array.isArray(c.finishes)?c.finishes:[];
    const r=c.rarity;
    // Normal (nonfoil)
    if(finishes.includes('nonfoil')){
      let p=0;
      if(r==='common')   p = ODDS.E_COMMON_SLOTS / nC;
      if(r==='uncommon') p = ODDS.E_UNCOMMON_SLOTS / nU;
      if(r==='rare')     p = (ODDS.RM_RARE + ODDS.WILD_RARE) / nR;
      if(r==='mythic')   p = (ODDS.RM_MYTHIC + ODDS.WILD_MYTHIC) / nM;
      if(p>0) pushRow(c,'LCI','normal',PM.point(p), priceUSD(c,'normal'), false,false);
    }
    // Foil (1 per pack across all rarities; split by FOIL_* shares)
    if(finishes.includes('foil')){
      let p=0;
      if(r==='common')   p = ODDS.FOIL_C / nC;
      if(r==='uncommon') p = ODDS.FOIL_U / nU;
      if(r==='rare')     p = ODDS.FOIL_R / nR;
      if(r==='mythic')   p = ODDS.FOIL_M / nM;
      if(p>0) pushRow(c,'LCI','foil',PM.point(p), priceUSD(c,'foil'), false,false);
    }
  }
}

function rowsFromREX(cards){
  const paper=cards.filter(c=> (c.games||[]).includes('paper'));
  const nonfoil=paper.filter(c=> (c.finishes||[]).includes('nonfoil'));
  const n=Math.max(1, nonfoil.length);
  // REX: ~1 in 12 Set Boosters; nonfoil only in Set Boosters
  const perPrint = (1/12) / n;
  for(const c of nonfoil){
    pushRow(c,'REX','normal',PM.point(perPrint), priceUSD(c,'normal'), false,false);
  }
}

function rowsFromSPG(cards){
  const { listRate, spgShare } = getListControls();
  if(listRate<=0 || spgShare<=0) return;
  const paper=cards.filter(c=> (c.games||[]).includes('paper'));
  const nf=paper.filter(c=> (c.finishes||[]).includes('nonfoil'));
  const n=Math.max(1,nf.length);
  // SPG are nonfoil borderless in the List slot of Set Boosters
  const perPrint = (listRate * spgShare) / n;
  for(const c of nf){
    pushRow(c,'SPG','normal',PM.point(perPrint), priceUSD(c,'normal'), /*isNonGame=*/true,false);
  }
}

function rowsFromPLST(cards){
  const { listRate, spgShare } = getListControls();
  const plstShare = Math.max(0, 1 - spgShare);
  if(listRate<=0 || plstShare<=0) return;
  const paper=cards.filter(c=> (c.games||[]).includes('paper'));
  const nf=paper.filter(c=> (c.finishes||[]).includes('nonfoil'));
  const n=Math.max(1,nf.length);
  // Model PLST as the remainder of the List slot (nonfoil)
  const perPrint = (listRate * plstShare) / n;
  for(const c of nf){
    pushRow(c,'PLST','normal',PM.point(perPrint), priceUSD(c,'normal'), /*isNonGame=*/true,false);
  }
}

function rowsFromTLCI(cards, tokenFallback){
  const { tokenRate } = getListControls();
  const paper=cards.filter(c=> (c.games||[]).includes('paper'));
  const n=Math.max(1, __TOKEN_POOL__);
  for(const c of paper){
    const val = priceUSD(c,'normal');
    const usedFallback = !Number.isFinite(val) && Number.isFinite(tokenFallback);
    pushRow(c,'TLCI','normal',PM.point(tokenRate/n), usedFallback?tokenFallback:val, true, usedFallback);
  }
}

function rowsFromALCI(cards, artFallback){
  const paper=cards.filter(c=> (c.games||[]).includes('paper'));
  __ART_POOL__ = paper.length || 1;
  for(const c of paper){
    const isSigned = /[A-Za-z]$/.test(c.collector_number||'') && c.collector_number.toLowerCase().endsWith('s');
    const pool = Math.max(1,__ART_POOL__);
    const p = isSigned ? (ODDS.ART_SIGNED/pool) : (ODDS.ART_NORMAL/pool);
    const val = priceUSD(c,'normal');
    const usedFallback = !Number.isFinite(val) && Number.isFinite(artFallback);
    pushRow(c,'ALCI', isSigned?'signed':'normal', PM.point(p), usedFallback?artFallback:val, true, usedFallback);
  }
}

/* ========= Topper EV (LCC Treasure Trove) ========= */
function computeTopperEV(cards){
  // Weighting per WotC: U 62%, R 28%, M 10% across 8/7/5 respectively
  const us = cards.filter(c=>c.rarity==='uncommon');
  const rs = cards.filter(c=>c.rarity==='rare');
  const ms = cards.filter(c=>c.rarity==='mythic');
  const nU = Math.max(1,us.length), nR=Math.max(1,rs.length), nM=Math.max(1,ms.length);
  const wU = 0.62 / nU, wR = 0.28 / nR, wM = 0.10 / nM;
  let est=0;
  for(const c of us){ const p=priceUSD(c,'normal'); if(Number.isFinite(p)) est+=p*wU; }
  for(const c of rs){ const p=priceUSD(c,'normal'); if(Number.isFinite(p)) est+=p*wR; }
  for(const c of ms){ const p=priceUSD(c,'normal'); if(Number.isFinite(p)) est+=p*wM; }
  __TOPPER_EST__ = est || 0;
}

/* ========= Aggregation & EV (from template, lightly adapted) ========= */
function aggregateFor(packs, includeNonGame=true){
  let lowCount=0,estCount=0,highCount=0, lowEV=0,estEV=0,highEV=0, missingPrice=0, fallbackUsed=0;
  for(const r of __ROW_MODELS__){
    if(!includeNonGame && r.isNonGame) continue;
    const cnt=countFromModel(r.model,packs,r.isNonGame); if(!cnt) continue;
    lowCount+=cnt.lo; estCount+=cnt.est; highCount+=cnt.hi;
    if(Number.isFinite(r.price)){ lowEV+=r.price*cnt.lo; estEV+=r.price*cnt.est; highEV+=r.price*cnt.hi; } else missingPrice++;
    if(r.fallback) fallbackUsed++;
  }
  return {lowCount,estCount,highCount,lowEV,estEV,highEV,missingPrice,fallbackUsed};
}
function aggregateSift(packs,minUSD){
  let include=0,exclude=0,missingPrice=0,nonGameIncluded=0;
  let lowEV=0,estEV=0,highEV=0, lowCount=0,estCount=0,highCount=0;
  for(const r of __ROW_MODELS__){
    const ok = Number.isFinite(r.price) && r.price>=minUSD;
    if(ok){
      include++; if(r.isNonGame) nonGameIncluded++;
      const cnt=countFromModel(r.model,packs,r.isNonGame); if(!cnt) continue;
      lowCount+=cnt.lo; estCount+=cnt.est; highCount+=cnt.hi;
      lowEV+=r.price*cnt.lo; estEV+=r.price*cnt.est; highEV+=r.price*cnt.hi;
    }else{
      exclude++; if(!Number.isFinite(r.price)) missingPrice++;
    }
  }
  return {include,exclude,nonGameIncluded,lowCount,estCount,highCount,lowEV,estEV,highEV,missingPrice};
}
function statRange(packs, useSift, minUSD){
  let meanPerPack=0, varPerPack=0, missingPrice=0;
  for(const r of __ROW_MODELS__){
    if(useSift && !(Number.isFinite(r.price) && r.price>=minUSD)) continue;
    if(!Number.isFinite(r.price)){ missingPrice++; continue; }
    const p = probPoint(r.model); if(!Number.isFinite(p)) continue;
    const pS = r.isNonGame ? p : (p*__NORM_SCALE__);
    meanPerPack += pS * r.price;
    varPerPack  += pS * (1-pS) * r.price * r.price;
  }
  const mean=meanPerPack*packs, sd=Math.sqrt(Math.max(0,varPerPack*packs));
  return {mean,sd,missingPrice};
}

/* ========= Sift table rendering (from template) ========= */
function toCsv(rows){
  return rows.map(r => r.map(v => {
    const s=String(v??'');
    return /[",\n]/.test(s)? '"'+s.replace(/"/g,'""')+'"' : s;
  }).join(',')).join('\n');
}
function renderSiftTable(minUSD){
  const body=document.getElementById('siftBody'); body.innerHTML='';
  for(const m of __META_ROWS__){
    const ok = Number.isFinite(m.price) && m.price>=minUSD;
    const cls= ok ? 'sift-ok' : 'sift-bad';
    const {min:pMin,max:pMax}=probMinMaxScaled(m.model,m.isNonGame);
    const c1k  = countFromModel(m.model,1000,   m.isNonGame);
    const c30k = countFromModel(m.model,30000,  m.isNonGame);
    const c300k= countFromModel(m.model,300000, m.isNonGame);

    const tr=document.createElement('tr'); tr.className=cls;
    const tds = [
      m.setTag, m.cn, m.rarity, /* link cell */, m.treatment,
      Number.isFinite(pMin)?(pMin*100).toFixed(5)+'%':'', Number.isFinite(pMax)?(pMax*100).toFixed(5)+'%':'', fmtUSD(m.price),
      fmtCount(c1k?c1k.lo:NaN), fmtCount(c1k?c1k.hi:NaN),
      fmtCount(c30k?c30k.lo:NaN), fmtCount(c30k?c30k.hi:NaN),
      fmtCount(c300k?c300k.lo:NaN), fmtCount(c300k?c300k.hi:NaN)
    ];
    let td=document.createElement('td'); td.textContent=tds[0]; tr.appendChild(td);
    td=document.createElement('td'); td.textContent=tds[1]; tr.appendChild(td);
    td=document.createElement('td'); td.textContent=tds[2]; tr.appendChild(td);
    td=document.createElement('td');
      if(m.url){ const a=document.createElement('a'); a.href=m.url; a.target='_blank'; a.rel='noopener noreferrer'; a.textContent=m.name; td.appendChild(a); }
      else td.textContent=m.name;
    tr.appendChild(td);
    td=document.createElement('td'); td.textContent=tds[4]; tr.appendChild(td);
    for(let i=5;i<tds.length;i++){ const t=document.createElement('td'); t.textContent=tds[i]; tr.appendChild(t); }
    body.appendChild(tr);
  }
  document.getElementById('siftTableWrap').style.display='';
}
function applySift(minUSD){
  renderSiftTable(minUSD);
  const header=['Set','Number','Rarity','Name','Treatment','Pack Prob Min (%)','Pack Prob Max (%)','Card Value (USD)','Per 1000 Min','Per 1000 Max','Per 30000 Min','Per 30000 Max','Per 300000 Min','Per 300000 Max'];
  const rows=[], tbody=document.getElementById('siftBody');
  for(const tr of tbody.querySelectorAll('tr')) rows.push(Array.from(tr.querySelectorAll('td')).map(td=>td.textContent));
  __SIFT_CSV__=toCsv([header,...rows]);
  document.getElementById('downloadSiftCsv').disabled=false;

  // Summary
  let include=0,exclude=0,missing=0; const min = parseUSD(document.getElementById('siftMin').value) ?? 0.00;
  for(const r of __ROW_MODELS__){
    if(!Number.isFinite(r.price)) { exclude++; missing++; continue; }
    if(r.price>=min) include++; else exclude++;
  }
  document.getElementById('siftSummary').innerHTML =
    `Sift ≥ <b>$${(min).toFixed(2)}</b> — Included: <b>${include.toLocaleString()}</b> / Excluded: <b>${exclude.toLocaleString()}</b>` +
    (missing? ` (no USD on ${missing})`:``);
}

/* ========= Purchase EV & Totals ========= */
function renderPurchaseEV(){
  const boxes=Math.max(0, parseFloat(document.getElementById('boxesToBuy').value)||0);
  const packs=boxes*PACKS_PER_BOX;
  const useSift=document.getElementById('useSiftForEV').checked;
  const minUSD=parseUSD(document.getElementById('siftMin').value) ?? 0.00;
  const mode=(document.querySelector('input[name="rangeMode"]:checked')||{}).value || 'stat';
  const conf=parseFloat(document.getElementById('confLevel').value)||95;
  const z=zFromConf(conf);

  let lowEV,estEV,highEV,tag,missingNote='';
  if(mode==='struct'){
    const agg = useSift ? aggregateSift(packs,minUSD) : aggregateFor(packs,true);
    lowEV=agg.lowEV; estEV=agg.estEV; highEV=agg.highEV;
    if(agg.missingPrice>0) missingNote=`${agg.missingPrice} rows without USD were excluded.`;
    tag='Structural model band (slot‑odds uncertainty)';
  }else{
    const {mean,sd,missingPrice}=statRange(packs,useSift,minUSD);
    estEV=mean; lowEV=Math.max(0, mean - z*sd); highEV=mean + z*sd;
    if(missingPrice>0) missingNote=`${missingPrice} rows without USD were excluded.`;
    tag=`Statistical ${conf}% interval (CLT)`;
  }

  // Add topper EV (per display) deterministically
  const topperOn = document.getElementById('includeTopper').checked;
  const topperAdd = topperOn ? (boxes * (__TOPPER_EST__||0)) : 0;
  lowEV+=topperAdd; estEV+=topperAdd; highEV+=topperAdd;

  const perBoxLow  = boxes>0 ? lowEV/boxes : 0;
  const perBoxEst  = boxes>0 ? estEV/boxes : 0;
  const perBoxHigh = boxes>0 ? highEV/boxes : 0;

  const evDiv=document.getElementById('purchaseEVContainer');
  evDiv.innerHTML=`
    <table>
      <thead><tr><th>Metric</th><th>Low</th><th>Est.</th><th>High</th></tr></thead>
      <tbody>
        <tr><td>${tag} — across ${packs.toLocaleString()} packs ${topperOn?'+ toppers':''}</td><td>$${money(lowEV)}</td><td>$${money(estEV)}</td><td>$${money(highEV)}</td></tr>
        <tr><td>${tag} — per ${PACKS_PER_BOX}-pack box${topperOn?' (+ topper)':''}</td><td>$${money(perBoxLow)}</td><td>$${money(perBoxEst)}</td><td>$${money(perBoxHigh)}</td></tr>
      </tbody>
    </table>`;
  evDiv.style.display='';

  const { listRate, spgShare } = getListControls();
  const notes=[];
  notes.push(`Boxes: ${boxes.toLocaleString()} × ${PACKS_PER_BOX} = ${packs.toLocaleString()} packs.`);
  notes.push(`Using ${useSift ? `Sift ≥ $${(Number.isFinite(minUSD)?minUSD:0).toFixed(2)}` : 'all prints'}.`);
  notes.push(`Final slot: List rate ${(listRate*100).toFixed(1)}% (SPG share ${(spgShare*100).toFixed(1)}%).`);
  if(topperOn) notes.push(`Topper EV per display (non‑foil): $${money(__TOPPER_EST__||0)} (U 62% / R 28% / M 10%).`);
  if(mode==='stat') notes.push('Variance: Σ p·(1−p)·value² per pack (independence approximation).');
  if(missingNote) notes.push(missingNote);
  document.getElementById('purchaseSummary').textContent=notes.join(' ');
  document.getElementById('rangeNotes').textContent = (mode==='struct')
    ? 'Structural range reflects slot‑odds uncertainty; scales roughly linearly with packs. (Topper added deterministically.)'
    : 'Statistical range reflects random pack variance; narrows with more boxes (~1/√n). (Topper added deterministically.)';

  renderTotalsTable();
}
function renderTotalsTable(){
  const boxes=Math.max(0, parseFloat(document.getElementById('boxesToBuy').value)||0);
  if(boxes<=0){ document.getElementById('totalsPanel').style.display='none'; return; }
  const P = boxes * PACKS_PER_BOX;

  // Exact items per pack: 12 playing + 1 art + 1 final-slot item
  const { listRate } = getListControls();
  const exactPlaying = 12 * P;
  const exactArt     = 1 * P;
  const exactFinal   = 1 * P; // token/ad or List
  const exactItems   = (12+1+1) * P;

  // EV for totals (ignore Sift)
  const {lowEV,estEV,highEV,lowCount,estCount,highCount,missingPrice,fallbackUsed} = (() => {
    const all = aggregateFor(P,true);
    const cardsOnly = aggregateFor(P,false);
    return { ...all, lowCount:cardsOnly.lowCount, estCount:cardsOnly.estCount, highCount:cardsOnly.highCount };
  })();

  const perBoxEst = boxes>0 ? estEV/boxes : 0;

  const body=document.getElementById('totalsBody');
  body.innerHTML=`
    <tr><td>Total expected cards + art + final‑slot @ ${P.toLocaleString()} packs (exact)</td>
        <td>${fmtInt(exactItems)}</td><td>${fmtInt(exactItems)}</td><td>${fmtInt(exactItems)}</td></tr>
    <tr><td>…of which art (exact)</td>
        <td>${fmtInt(exactArt)}</td><td>${fmtInt(exactArt)}</td><td>${fmtInt(exactArt)}</td></tr>
    <tr><td>…of which token/ad or List (exact)</td>
        <td>${fmtInt(exactFinal)}</td><td>${fmtInt(exactFinal)}</td><td>${fmtInt(exactFinal)}</td></tr>
    <tr><td>…of which playing cards (exact target)</td>
        <td>${fmtInt(exactPlaying)}</td><td>${fmtInt(exactPlaying)}</td><td>${fmtInt(exactPlaying)}</td></tr>
    <tr><td>Model‑check: sum across per‑print playing cards (normalized)</td>
        <td>${fmtInt(lowCount)}</td><td>${fmtInt(estCount)}</td><td>${fmtInt(highCount)}</td></tr>
    <tr><td>Total EV across ${P.toLocaleString()} packs</td>
        <td>$${money(lowEV)}</td><td>$${money(estEV)}</td><td>$${money(highEV)}</td></tr>
    <tr><td>EV per ${PACKS_PER_BOX}-pack box (${boxes.toLocaleString()} boxes)</td>
        <td>$${money(perBoxEst)}</td><td>$${money(perBoxEst)}</td><td>$${money(perBoxEst)}</td></tr>`;

  const notes=[];
  if(missingPrice>0) notes.push(`${missingPrice} rows had no USD price (fallbacks used where provided).`);
  const tokenFallback=parseUSD(document.getElementById('tokenFallback').value);
  if(__ROW_MODELS__.some(r=>r.fallback)) notes.push(`Some token/art rows used fallback values (token fallback = $${(tokenFallback??0).toFixed(2)}).`);
  notes.push('Playing‑card probabilities are scaled so EST sums to exactly 12 per pack.');
  notes.push('Topper EV (if included) is added outside the per‑pack normalization.');
  document.getElementById('totalsNotes').textContent = 'Notes: ' + notes.join(' ');
  document.getElementById('totalsPanel').style.display='';
  const det=document.getElementById('totalsDetails'); if(det) det.open=false;
}

/* ========= Build flow ========= */
async function build(){
  // Reset UI
  document.getElementById('errorBox').style.display='none';
  document.getElementById('errorMsg').textContent='';
  document.getElementById('errorDetails').textContent='';
  document.getElementById('purchasePanel').style.display='none';
  document.getElementById('purchaseEVContainer').style.display='none';
  document.getElementById('siftPanel').style.display='none';
  document.getElementById('siftTableWrap').style.display='none';
  document.getElementById('preview').value='';
  document.getElementById('status').textContent='Building list…';
  document.getElementById('totalsPanel').style.display='none';
  __ROW_MODELS__=[]; __META_ROWS__=[]; __SIFT_CSV__=''; __ERRORS__=[]; __TOPPER_EST__=0;

  const englishOnly=document.getElementById('englishOnly').checked;
  const incLCI=document.getElementById('includeLCI').checked;
  const incREX=document.getElementById('includeREX').checked;
  const incSPG=document.getElementById('includeSPG').checked;
  const incPLST=document.getElementById('includePLST').checked;
  const incTOK=document.getElementById('includeTOK').checked;
  const incART=document.getElementById('includeART').checked;
  const incTOP=document.getElementById('includeTopper').checked;

  __TOKEN_POOL__=Math.max(1, parseInt(document.getElementById('tokenPool').value,10)||20);
  const tokenFallback=parseUSD(document.getElementById('tokenFallback').value);
  const artFallback=parseUSD(document.getElementById('artFallback').value);

  const status=document.getElementById('status');
  const counts=document.getElementById('counts');
  const queriesEl=document.getElementById('queries');

  // Build queries list
  const qList=[];
  if(incLCI)  qList.push(['LCI',    buildQuery('LCI',  englishOnly)]);
  if(incREX)  qList.push(['REX',    buildQuery('REX',  document.getElementById('englishREXonly').checked)]);
  if(incSPG)  qList.push(['SPG',    buildQuery('SPG',  englishOnly)]);
  if(incPLST) qList.push(['PLST',   buildQuery('PLST', englishOnly)]);
  if(incTOK)  qList.push(['TLCI',   buildQuery('TLCI', englishOnly)]);
  if(incART)  qList.push(['ALCI',   buildQuery('ALCI', englishOnly)]);
  if(incTOP)  qList.push(['TOPPER', buildQuery('TOPPER', englishOnly)]);
  queriesEl.textContent = qList.map(([tag,q])=>`${tag}: ${q}`).join('\n');

  // Fetch (non‑blocking per set)
  const results=[];
  for(const [tag,q] of qList){
    const cards=await fetchAllPagesNonBlocking(q,tag,status);
    results.push([tag,cards]);
  }

  // Build rows
  for(const [tag,cards] of results){
    if(tag==='LCI')    rowsFromLCI(cards);
    if(tag==='REX')    rowsFromREX(cards);
    if(tag==='SPG')    rowsFromSPG(cards);
    if(tag==='PLST')   rowsFromPLST(cards);
    if(tag==='TLCI')   rowsFromTLCI(cards, tokenFallback);
    if(tag==='ALCI')   rowsFromALCI(cards, artFallback);
    if(tag==='TOPPER') computeTopperEV(cards);
  }

  // Normalize playing cards to 12 per pack (EST)
  const raw=aggregateFor(1,/*includeNonGame=*/false);
  __NORM_SCALE__ = raw && raw.estCount ? (12/raw.estCount) : 1;

  // Sort rows (set → CN → name → treatment)
  __META_ROWS__.sort((a,b)=>{
    if(a.setTag!==b.setTag) return a.setTag.localeCompare(b.setTag);
    const pa=(a.cn||'').match(/^(\d+)(.*)$/)||[], pb=(b.cn||'').match(/^(\d+)(.*)$/)||[];
    const na=pa[1]?parseInt(pa[1],10):0, nb=pb[1]?parseInt(pb[1],10):0;
    if(na!==nb) return na-nb; const sa=pa[2]||'', sb=pb[2]||''; if(sa!==sb) return sa.localeCompare(sb);
    if(a.name!==b.name) return a.name.localeCompare(b.name);
    return a.treatment.localeCompare(b.treatment);
  });

  // CSV (all rows)
  const header=['Set','Number','Rarity','Name','Treatment','Pack Prob Min (%)','Pack Prob Max (%)','Card Value (USD)','Per 1000 Min','Per 1000 Max','Per 30000 Min','Per 30000 Max','Per 300000 Min','Per 300000 Max'];
  const allRows = __META_ROWS__.map(m=>{
    const {min:pMin,max:pMax}=probMinMaxScaled(m.model,m.isNonGame);
    const c1k=countFromModel(m.model,1000,m.isNonGame);
    const c30k=countFromModel(m.model,30000,m.isNonGame);
    const c300k=countFromModel(m.model,300000,m.isNonGame);
    return [
      m.setTag, m.cn, m.rarity, m.name, m.treatment,
      Number.isFinite(pMin)?(pMin*100).toFixed(5)+'%':'', Number.isFinite(pMax)?(pMax*100).toFixed(5)+'%':'', fmtUSD(m.price),
      fmtCount(c1k?c1k.lo:NaN), fmtCount(c1k?c1k.hi:NaN),
      fmtCount(c30k?c30k.lo:NaN), fmtCount(c30k?c30k.hi:NaN),
      fmtCount(c300k?c300k.lo:NaN), fmtCount(c300k?c300k.hi:NaN)
    ];
  });
  const csv = toCsv([header, ...allRows]); window.__CSV__=csv; document.getElementById('preview').value=csv.slice(0,250000);
  document.getElementById('downloadCsv').disabled=false;
  document.getElementById('copyCsv').disabled=false;

  // Enable Sift + Purchase EV
  document.getElementById('siftPanel').style.display='';
  document.getElementById('applySift').disabled=false;
  document.getElementById('purchasePanel').style.display='';
  document.getElementById('calcEV').disabled=false;

  // Auto‑apply Sift at default and render EV
  const minUSD=parseUSD(document.getElementById('siftMin').value) ?? 0.00;
  applySift(minUSD);
  renderPurchaseEV();

  // Counts
  const lciCount = __META_ROWS__.filter(r=>r.setTag==='LCI').length;
  const rexCount = __META_ROWS__.filter(r=>r.setTag==='REX').length;
  const spgCount = __META_ROWS__.filter(r=>r.setTag==='SPG').length;
  const plstCount= __META_ROWS__.filter(r=>r.setTag==='PLST').length;
  const tokCount = __META_ROWS__.filter(r=>r.setTag==='TLCI').length;
  const artCount = __META_ROWS__.filter(r=>r.setTag==='ALCI').length;
  document.getElementById('counts').innerHTML =
    `Built <b>${__META_ROWS__.length.toLocaleString()}</b> rows — LCI: <b>${lciCount}</b>, REX: <b>${rexCount}</b>, SPG: <b>${spgCount}</b>, PLST: <b>${plstCount}</b>, TLCI: <b>${tokCount}</b>, ALCI: <b>${artCount}</b>. Topper EV per display: <b>$${money(__TOPPER_EST__||0)}</b>.`;

  // Errors (if any)
  if(__ERRORS__.length){
    document.getElementById('errorBox').style.display='';
    document.getElementById('errorMsg').innerHTML = `${__ERRORS__.length} fetch issue(s) occurred; other sets were loaded successfully.`;
    const detail = __ERRORS__.map(e => `Set: ${e.set}\nStatus: ${e.status}\nQuery: ${e.query}\n—\n${String(e.details||'').slice(0,800)}\n`).join('\n\n');
    document.getElementById('errorDetails').textContent = detail;
  }

  document.getElementById('status').textContent = `Done. (Normalization factor: ${__NORM_SCALE__.toFixed(5)}; Sift auto‑applied at $${(Number.isFinite(minUSD)?minUSD:0).toFixed(2)})`;
}

/* ========= Hooks ========= */
document.getElementById('buildBtn').addEventListener('click', build);
document.getElementById('downloadCsv').addEventListener('click', ()=>{ if(window.__CSV__) {
  const blob=new Blob(["\uFEFF"+window.__CSV__],{type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='LCI_SetBooster_List_Normalized.csv';
  document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
}});
document.getElementById('copyCsv').addEventListener('click', async ()=>{ if(!window.__CSV__) return;
  try{ await navigator.clipboard.writeText(window.__CSV__); alert('CSV copied to clipboard.'); }
  catch{ const t=document.getElementById('preview'); t.focus(); t.select(); alert('Select all (Ctrl/Cmd+A) and copy (Ctrl/Cmd+C).'); }
});
document.getElementById('applySift').addEventListener('click', ()=>{
  const minUSD=parseUSD(document.getElementById('siftMin').value) ?? 0.00;
  applySift(minUSD); renderPurchaseEV();
});
document.getElementById('downloadSiftCsv').addEventListener('click', ()=>{ if(__SIFT_CSV__) {
  const blob=new Blob(["\uFEFF"+__SIFT_CSV__],{type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='LCI_SetBooster_SiftTable.csv';
  document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
}});
document.getElementById('calcEV').addEventListener('click', renderPurchaseEV);
document.getElementById('boxesToBuy').addEventListener('change', renderPurchaseEV);
document.getElementById('useSiftForEV').addEventListener('change', renderPurchaseEV);
document.getElementById('siftMin').addEventListener('change', ()=>{
  const v=parseUSD(document.getElementById('siftMin').value) ?? 0.00;
  applySift(v); renderPurchaseEV();
});
document.getElementById('confLevel').addEventListener('change', renderPurchaseEV);
document.getElementById('includeTopper').addEventListener('change', renderPurchaseEV);
document.getElementById('listRate').addEventListener('change', ()=>{ build(); });
document.getElementById('spgShare').addEventListener('change', ()=>{ build(); });
for(const r of document.querySelectorAll('input[name="rangeMode"]')) r.addEventListener('change', renderPurchaseEV);

// Auto‑build on page load
window.addEventListener('DOMContentLoaded', build);
</script>
<script>
/* === SIFT MIN CLAMP ($0.01) — drop‑in for FDN ===
   Paste anywhere after parseUSD() is defined.
   Enforces $0.01 whenever Sift is 0, negative, blank, or NaN.
*/
(function(){
  function clampSiftMin(){
    const el = document.getElementById('siftMin');
    if(!el) return 0.01;
    let v = parseUSD(el.value);
    if(!Number.isFinite(v) || v <= 0) v = 0.01;
    el.value = v.toFixed(2);   // keep UI in sync with the enforced value
    return v;
  }

  // Expose in case you want to call it explicitly elsewhere.
  window.getSiftMinClamped = clampSiftMin;

  // Clamp once on load.
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', clampSiftMin, { once:true });
  } else {
    clampSiftMin();
  }

  // Clamp *before* your existing click handlers for Apply Sift / Calculate EV.
  // (capture = true ensures this runs first)
  document.addEventListener('click', function(e){
    const id = e.target && e.target.id;
    if (id === 'applySift' || id === 'calcEV') clampSiftMin();
  }, true);

  // Also clamp when the Sift field is committed.
  document.getElementById('siftMin')?.addEventListener('change', clampSiftMin, true);
})();
</script>
</body>
</html>
