<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Modern Horizons 3 — Play Booster EV</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html{background-color:#0b0d10}
  /* Scoped styles for portability */
  .eoe-app{
    --bg:#0b0d10; --fg:#e8ecf1; --muted:#a7b0bb; --acc:#6ac1ff;
    --card:#151a20; --line:#222a33; --ok:#1e7f3c; --warn:#9b2c2c;
    --hi-bg:rgba(106,193,255,.14); --hi-line:#6ac1ff;
    --est-bg:rgba(106,193,255,.18); --est-line:#6ac1ff;
    color:var(--fg); background:var(--bg); font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    max-width:1120px; margin:32px auto; padding:0 16px; box-sizing:border-box; min-height:100vh;
  }
  .eoe-app a{color:var(--acc); text-decoration:underline}
  .eoe-app h1{font-size:22px;margin:0 0 12px}
  .eoe-app p.lede{color:var(--muted);margin:0 0 16px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:10px;padding:16px;margin:16px 0}
  .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  label{display:flex;gap:6px;align-items:center}
  input[type="number"],input[type="text"],select{
    background:#0e1216;color:#cfe3f5;border:1px solid #2a3541;border-radius:6px;padding:6px
  }
  button{appearance:none;border:1px solid #2c3845;background:#1b232c;color:var(--fg);padding:10px 14px;border-radius:8px;cursor:pointer}
  button[disabled]{opacity:.55;cursor:default}
  .btn-primary{border-color:var(--hi-line);background:linear-gradient(180deg,#203245,#1a2530);color:#dff1ff;font-weight:600;animation:pulse 2.2s infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(106,193,255,.45)}70%{box-shadow:0 0 0 10px rgba(106,193,255,0)}100%{box-shadow:0 0 0 0 rgba(106,193,255,0)}}
  .hi-label{border:1px solid var(--hi-line);background:var(--hi-bg);border-radius:8px;padding:6px 8px}
  .hi-inline{display:flex;align-items:center;gap:6px;border:1px solid var(--hi-line);background:var(--hi-bg);border-radius:8px;padding:6px 8px}

  /* Banner header/footer */
  .freBanner{display:flex;justify-content:center;margin:8px 0 16px}
  .freBanner img{max-width:420px;width:100%;height:auto;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  @media (max-width:640px){ .freBanner img{max-width:300px} }

  /* Vertical list for checkboxes — one per row */
  .vert-list{margin-top:8px}
  .vert-list label{display:flex; align-items:center; gap:8px; margin:6px 0}

  /* Tables */
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid #2a3541;padding:6px 8px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  thead th{background:#0e1216;position:sticky;top:0;z-index:1}
  tbody tr:nth-child(even){background:#12171d}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3541}
  .pill.ok{background:rgba(30,127,60,.20);color:#d9ffe3;border-color:#1e7f3c}
  .pill.bad{background:rgba(155,44,44,.16);color:#ffdede;border-color:#9b2c2c}
  .sift-ok{background:rgba(30,127,60,.12)!important}
  .sift-bad{background:rgba(155,44,44,.10)!important}
  .sift-tablewrap{max-height:520px;overflow:auto;border:1px solid #2a3541;border-radius:8px;margin-top:8px}

  /* Highlight Est. column */
  .evbox table th:nth-child(3), .evbox table td:nth-child(3){
    background:var(--est-bg); border-color:var(--est-line); border-left-color:var(--est-line);
    color:#eaf6ff; font-weight:700;
  }
  .evbox table th:nth-child(2), .evbox table td:nth-child(2){border-right-color:var(--est-line)}

  /* Collapsible totals */
  details.eoe-collapse>summary{
    cursor:pointer;list-style:none;display:flex;justify-content:space-between;align-items:center;
    padding:8px 10px;border:1px solid #2a3541;border-radius:8px;background:#0e1216;color:#dfeeff;font-weight:600
  }
  details.eoe-collapse>summary::-webkit-details-marker{display:none}
  details.eoe-collapse>summary::after{content:'▼';opacity:.8;transform:rotate(-90deg);transition:transform .18s;margin-left:12px;font-size:12px}
  details.eoe-collapse[open]>summary::after{transform:rotate(0deg)}
  details.eoe-collapse .content{margin-top:10px}
</style>
</head>
<body>
<main class="eoe-app" role="main" aria-label="MH3 Play Booster EV">
  <!-- Banner header (links home) -->
  <div class="freBanner">
    <a href="./index.html"><img src="freEV-banner.png" alt="FreEV — Spend your money on cards not calculators"></a>
  </div>

  <h1>Modern Horizons 3 — Play Booster EV</h1>
  <p class="lede">
    Builds on load using Scryfall. Playing‑card odds are normalized so the per‑pack <b>EST totals 14 cards</b>.
    Non‑game slot (token/ad/art) is modeled separately (65% token/ad, 30% art, 5% signed art).
    <br><b>Retro modeling:</b> R/M slot <b>2.1%</b> (MH3 retro R/M only) + Wildcard <b>4.2%</b> (MH3 retro + H2R). 
  </p>

  <div class="panel">
    <strong>Refresh data</strong>
    <div class="vert-list">
      <label><input type="checkbox" id="englishOnly" checked> English‑only</label>
      <label><input type="checkbox" id="includeMH3" checked> Include <b>MH3</b> (main set, <code>is:booster</code>, excludes retro)</label>
      <label><input type="checkbox" id="includeRETRO" checked> Include <b>Retro Frame</b> (MH3 <code>frame:1997</code> + <code>H2R</code> bonus sheet)</label>
      <label><input type="checkbox" id="includeSPG" checked> Include <b>SPG</b> (MH3 wave; nonfoil only)</label>
    </div>
    <div class="row" style="margin-top:6px">
      <label><input type="checkbox" id="includeTOK"> Include <b>TMH3</b> Tokens</label>
      <label>Token fallback (USD): <input type="text" id="tokenFallback" value="0.05" size="6" title="Used if token price missing"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label><input type="checkbox" id="includeART"> Include <b>AMH3</b> Art Series (normal + signed)</label>
      <label>Art fallback (USD): <input type="text" id="artFallback" value="0.00" size="6" title="Used if art price missing"></label>
    </div>
    <div class="actions">
      <button id="buildBtn" class="btn-primary" title="Fetch live Scryfall data and recompute everything">Refresh List</button>
      <button id="downloadCsv" disabled>Download CSV</button>
      <button id="copyCsv" disabled>Copy CSV</button>
    </div>
    <div id="status" class="note" aria-live="polite">Preparing…</div>
    <div id="counts" class="note"></div>
  </div>

  <!-- Purchase EV -->
  <div id="purchasePanel" class="panel" style="display:none">
    <strong>Purchase EV Calculator</strong>
    <div class="row" style="margin-top:6px">
      <label class="hi-label">Boxes to buy: <input type="number" id="boxesToBuy" value="1" min="0" step="1" style="width:10ch"></label>
      <span class="hi-inline" title="Only count prints with Card Value ≥ this amount">
        <input type="checkbox" id="useSiftForEV" checked>
        <b>Use Sift (≥)</b>
        <input type="text" id="siftMin" value="0.25" style="width:8ch">
      </span>
    </div>
    <div class="row" style="margin-top:6px">
      <label><input type="radio" name="rangeMode" value="stat" checked> Statistical range (CLT)</label>
      <label><input type="radio" name="rangeMode" value="struct"> Structural range (slot band)</label>
      <label>Confidence:
        <select id="confLevel">
          <option value="68">68% (~1σ)</option>
          <option value="90">90% (~1.645σ)</option>
          <option value="95" selected>95% (~1.96σ)</option>
          <option value="99">99% (~2.576σ)</option>
        </select>
      </label>
      <button id="calcEV" disabled>Calculate EV</button>
    </div>
    <div id="purchaseSummary" class="note"></div>
    <div id="purchaseEVContainer" class="evbox" style="display:none"></div>
    <div id="rangeNotes" class="note"></div>
  </div>

  <!-- Sift table -->
  <div id="siftPanel" class="panel" style="display:none">
    <strong>Row List (linked)</strong>
    <div class="row">
      <span class="pill ok">≥ threshold</span>
      <span class="pill bad">&lt; threshold</span>
      <button id="applySift" disabled>Re‑Apply Sift</button>
      <button id="downloadSiftCsv" disabled>Download Sift Table</button>
    </div>
    <div id="siftSummary" class="note" aria-live="polite"></div>
    <div class="sift-tablewrap" id="siftTableWrap" style="display:none">
      <table id="siftTable">
        <thead>
          <tr>
            <th>Set</th><th>No.</th><th>R</th><th>Name</th><th>Treat</th>
            <th>Pack Prob Min (%)</th><th>Pack Prob Max (%)</th><th>Card Value (USD)</th>
            <th>Per 1000 Min</th><th>Per 1000 Max</th>
            <th>Per 30000 Min</th><th>Per 30000 Max</th>
            <th>Per 300000 Min</th><th>Per 300000 Max</th>
          </tr>
        </thead>
        <tbody id="siftBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Error -->
  <div id="errorBox" class="panel error-panel" style="display:none">
    <h2>Load failed</h2>
    <div id="errorMsg"></div>
    <pre id="errorDetails"></pre>
  </div>

  <!-- CSV -->
  <div class="panel">
    <strong>CSV preview</strong>
    <textarea id="preview" placeholder="Your CSV will appear after the list builds…" style="width:100%;min-height:220px;background:#0e1216;color:#cfe3f5;border:1px solid #2a3541;border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;"></textarea>
    <details>
      <summary>Advanced: Scryfall queries</summary>
      <pre id="queries" style="white-space:pre-wrap"></pre>
    </details>
  </div>

  <!-- Totals (collapsible; default closed) -->
  <div id="totalsPanel" class="panel" style="display:none">
    <details id="totalsDetails" class="eoe-collapse">
      <summary><strong>Totals for Your Purchase Size (No sift, Developer Model check)</strong></summary>
      <div class="content">
        <div class="note">
          Columns show <em>Low / Est. / High</em>. Totals <b>ignore Sift</b> and include token/art values via fallbacks when missing.
          Playing‑card probabilities are normalized so EST sums to 14 per pack; retro fixed shares are reserved first.
        </div>
        <table>
          <thead><tr><th>Metric</th><th>Low</th><th>Est.</th><th>High</th></tr></thead>
          <tbody id="totalsBody"></tbody>
        </table>
        <div id="totalsNotes" class="note"></div>
      </div>
    </details>
  </div>

  <!-- Banner footer (links home) -->
  <div class="freBanner">
    <a href="./index.html"><img src="freEV-banner.png" alt="FreEV — Spend your money on cards not calculators"></a>
  </div>
</main>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LWMRXKNY5X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-LWMRXKNY5X');
</script>

<script>
/* ============================ Helpers ============================ */
const rarityLetter = r => ({common:'C',uncommon:'U',rare:'R',mythic:'M'}[r] || (r?r[0].toUpperCase():'' ));
const sleep = ms => new Promise(res=>setTimeout(res,ms));
const padCollector = s => { const m=String(s||'').match(/^(\d+)(.*)$/); return m?m[1].padStart(4,'0')+(m[2]||''):(s||''); };
const baseCN = s => { const m=String(s||'').match(/^(\d+)/); return m?parseInt(m[1],10):NaN; };
const parseUSD = s => { const n=parseFloat(String(s).replace(/[^0-9.]/g,'')); return Number.isFinite(n)?n:null; };
const money = n => Number.isFinite(n)? n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}) : '';
const fmtUSD = n => money(n);
const fmtCount = n => !Number.isFinite(n)? '' : (Math.abs(n-Math.round(n))<1e-9? String(Math.round(n)) : (n>=100?n.toFixed(1):n>=10?n.toFixed(2):n.toFixed(3)));
const fmtInt = n => Number.isFinite(n)? Math.round(n).toLocaleString() : '';
const zFromConf = c => { c=Math.round(c); if(c>=99)return 2.576; if(c>=95)return 1.96; if(c>=90)return 1.645; if(c>=68)return 1.0; return 1.96; };
const priceUSD = (card,treat) => { const p=(treat==='foil'?card?.prices?.usd_foil:card?.prices?.usd); const f=parseFloat(p); return Number.isFinite(f)?f:null; };

/* ========================= Model constants =========================
   - Non‑game slot: 65% token/ad, 30% art, 5% signed art.
   - R/M slot baseline ~ 7/8 vs 1/8; foil slot rarity split heuristic.
   - SPG: 1/64 common replacement (nonfoil).
   - Retro (MH3 only): official shares from Wizards
        • R/M slot retro total = 0.021 packs  (2.1%)
        • Wildcard retro total = 0.042 packs  (4.2%)
*/
const PACKS_PER_BOX = 36;

const MH3_ODDS = {
  COMMON_SLOTS: 6.5 + 0.125 - (1/64),
  UNCOMMON_SLOTS: 3 + 0.625,
  RARE_SLOT: 1,
  WILDCARD_RM: 1/12,
  RM_RARE_RATE: 7/8,
  RM_MYTHIC_RATE: 1/8,
  FOIL_C: 0.58, FOIL_U: 0.32, FOIL_R: 0.064, FOIL_M: 0.011,
  LAND_SLOT: 1,
  LAND_FOIL_WITHIN: 0.20,
  NONGAME_TOKEN: 0.65, NONGAME_ART: 0.30, NONGAME_ART_SIGNED: 0.05,
  SPG_PER_PACK: 1/64,
  RETRO_RM_TOTAL: 0.021,
  RETRO_WC_TOTAL: 0.042
};

/* ============================ State ============================ */
let __ROW_MODELS__ = []; // { model, price, nonGame, fallback, url, noScale }
let __META_ROWS__  = []; // { setTag, cn, rarity, name, treatment, model, price, nonGame, url }
let __SIFT_CSV__   = '';
let __NORM_SCALE__ = 1;
let __FIXED_SHARE__= 0;   // reserved fixed share (retro)

/* ========================= Scryfall I/O ========================= */
function buildQuery(tag, englishOnly){
  let q='';
  if(tag==='MH3BASE') q='e:mh3 is:booster -frame:1997';
  // FIX: remove is:booster and include H2R retro bonus sheet
  if(tag==='RETRO')   q='(e:mh3 frame:1997) OR e:h2r -is:promo';
  if(tag==='SPG')     q='e:spg'; // filtered by released_at in JS
  if(tag==='TMH3')    q='e:tmh3 (layout:token or layout:double_faced_token or layout:emblem)';
  if(tag==='AMH3')    q='e:amh3';
  if(englishOnly) q+=' lang:en';
  return q;
}
async function fetchAllPages(q, tagLabel, statusEl){
  const base='https://api.scryfall.com/cards/search?unique=prints&order=set&dir=asc&q=';
  let url=base+encodeURIComponent(q), out=[], page=1;
  while(url){
    statusEl.textContent=`Fetching ${tagLabel}: page ${page}…`;
    let resp;
    try{ resp=await fetch(url); }catch(e){ throw {set:tagLabel,query:q,status:'NETWORK',details:e?.message||String(e)}; }
    if(!resp.ok){ const text=await resp.text().catch(()=> ''); throw {set:tagLabel,query:q,status:resp.status,details:text}; }
    const json=await resp.json();
    out = out.concat(json.data||[]);
    url = json.has_more ? json.next_page : null;
    page++; if(url) await sleep(120);
  }
  return out;
}

/* ======================= Probability models ======================= */
const PM = {
  point: p => ({ type:'point', p }),
  range: (lo,hi) => ({ type:'range', lo, hi }),
  max: max => ({ type:'max', max }),
  fixed: p => ({ type:'fixed', p }) // not scaled by normalization
};
function countFromModelRaw(model,packs){
  if(!model) return null;
  if(model.type==='point') return { lo:model.p*packs, est:model.p*packs, hi:model.p*packs, max:model.p*packs };
  if(model.type==='range') return { lo:model.lo*packs, est:((model.lo+model.hi)/2)*packs, hi:model.hi*packs, max:model.hi*packs };
  if(model.type==='max')   return { lo:0, est:(model.max/2)*packs, hi:model.max*packs, max:model.max*packs };
  if(model.type==='fixed') return { lo:model.p*packs, est:model.p*packs, hi:model.p*packs, max:model.p*packs };
  return null;
}
function probPoint(model){
  if(!model) return null;
  if(model.type==='point') return model.p;
  if(model.type==='range') return (model.lo+model.hi)/2;
  if(model.type==='max')   return model.max/2;
  if(model.type==='fixed') return model.p;
  return null;
}
function countFromModel(model,packs,nonGame=false,noScale=false){
  const c=countFromModelRaw(model,packs); if(!c) return c;
  return (nonGame||noScale)? c : { lo:c.lo*__NORM_SCALE__, est:c.est*__NORM_SCALE__, hi:c.hi*__NORM_SCALE__, max:c.max*__NORM_SCALE__ };
}

/* ====================== Row assembly helpers ====================== */
function pushRow(card, setTag, treatment, model, price, nonGame=false, fallbackUsed=false, noScale=false){
  const cn = padCollector(card.collector_number);
  const rarity = card.rarity ? rarityLetter(card.rarity) : 'C';
  const row = { setTag, cn, rarity, name: card.name, treatment, model, price, nonGame, url: card.scryfall_uri||'' };
  __META_ROWS__.push(row);
  __ROW_MODELS__.push({ model, price, nonGame, fallback: fallbackUsed, noScale });
  if(!nonGame && noScale){ const p=probPoint(model); if(Number.isFinite(p)) __FIXED_SHARE__ += p; }
}

/* ========================= Build the dataset ========================= */
async function build(){
  // Reset UI
  document.getElementById('errorBox').style.display='none';
  document.getElementById('purchasePanel').style.display='none';
  document.getElementById('purchaseEVContainer').style.display='none';
  document.getElementById('siftPanel').style.display='none';
  document.getElementById('siftTableWrap').style.display='none';
  document.getElementById('siftSummary').textContent='';
  document.getElementById('preview').value='';
  document.getElementById('status').textContent='Building list…';
  document.getElementById('totalsPanel').style.display='none';
  const det=document.getElementById('totalsDetails'); if(det) det.open=false;
  document.getElementById('totalsBody').innerHTML=''; document.getElementById('totalsNotes').textContent='';

  __ROW_MODELS__=[]; __META_ROWS__=[]; __SIFT_CSV__=''; __NORM_SCALE__=1; __FIXED_SHARE__=0;

  // Options
  const englishOnly=document.getElementById('englishOnly').checked;
  const incMH3=document.getElementById('includeMH3').checked;
  const incRETRO=document.getElementById('includeRETRO').checked;
  const incSPG=document.getElementById('includeSPG').checked;
  const incTOK=document.getElementById('includeTOK').checked;
  const incART=document.getElementById('includeART').checked;
  const tokenFallback=parseUSD(document.getElementById('tokenFallback').value);
  const artFallback=parseUSD(document.getElementById('artFallback').value);

  const status=document.getElementById('status');
  const queriesEl=document.getElementById('queries');

  const qList=[];
  if(incMH3)   qList.push(['MH3BASE', buildQuery('MH3BASE', englishOnly)]);
  if(incRETRO) qList.push(['RETRO',   buildQuery('RETRO',   englishOnly)]);
  if(incSPG)   qList.push(['SPG',     buildQuery('SPG',     englishOnly)]);
  if(incTOK)   qList.push(['TMH3',    buildQuery('TMH3',    englishOnly)]);
  if(incART)   qList.push(['AMH3',    buildQuery('AMH3',    englishOnly)]);
  queriesEl.textContent = qList.map(([tag,q])=>`${tag}: ${q}`).join('\n');

  try{
    // Fetch each dataset
    const results=[];
    for(const [tag,q] of qList){ const cards=await fetchAllPages(q,tag,status); results.push([tag,cards]); }
    const data = Object.fromEntries(results);

    // Filter SPG to MH3 wave (global tabletop launch ~2024‑06‑14)
    const spgAll = (data.SPG||[]).filter(c => (c.games||[]).includes('paper'));
    const spgMH3 = spgAll.filter(c => String(c.released_at||'').startsWith('2024-06-14')); // MH3 launch wave

    // Pools
    const mh3Base = (data.MH3BASE||[]).filter(c => (c.games||[]).includes('paper'));
    const retroFetched = (data.RETRO||[]).filter(c => (c.games||[]).includes('paper'));
    const tokAll  = (data.TMH3||[]).filter(c => (c.games||[]).includes('paper'));
    const artAll  = (data.AMH3||[]).filter(c => (c.games||[]).includes('paper'));

    // Split helpers
    const isLand = c => /Land/i.test(c.type_line||'');
    const isBasic = c => /Basic/i.test(c.type_line||'');

    // ===== MH3 Base (no retro) — nonfoil + land-slot foils =====
    const commons    = mh3Base.filter(c => c.rarity==='common'   && !isLand(c));
    const uncommons  = mh3Base.filter(c => c.rarity==='uncommon' && !isLand(c));
    const rares      = mh3Base.filter(c => c.rarity==='rare');
    const mythics    = mh3Base.filter(c => c.rarity==='mythic');
    const basics     = mh3Base.filter(isBasic);

    const P = MH3_ODDS;
    const pCommonNF   = (commons.length>0)   ? (P.COMMON_SLOTS / commons.length) : 0;
    const pUncommonNF = (uncommons.length>0) ? (P.UNCOMMON_SLOTS / uncommons.length) : 0;
    const pRslotRare   = (rares.length>0)   ? (P.RM_RARE_RATE   / rares.length)   : 0;
    const pRslotMythic = (mythics.length>0) ? (P.RM_MYTHIC_RATE / mythics.length) : 0;

    const wcRM = P.WILDCARD_RM, wcCU = 1 - wcRM;
    const cuTotal = (commons.length + uncommons.length) || 1;
    const wcCommonShare   = wcCU * (commons.length   / cuTotal);
    const wcUncommonShare = wcCU * (uncommons.length / cuTotal);
    const pWcCommon   = (commons.length>0)   ? (wcCommonShare   / commons.length)   : 0;
    const pWcUncommon = (uncommons.length>0) ? (wcUncommonShare / uncommons.length) : 0;
    const pWcRare     = (rares.length>0)     ? (wcRM*P.RM_RARE_RATE   / rares.length)   : 0;
    const pWcMythic   = (mythics.length>0)   ? (wcRM*P.RM_MYTHIC_RATE / mythics.length) : 0;

    const pLandNF = (basics.length>0) ? (P.LAND_SLOT*(1-P.LAND_FOIL_WITHIN)/basics.length) : 0;
    const pLandF  = (basics.length>0) ? (P.LAND_SLOT*P.LAND_FOIL_WITHIN     /basics.length) : 0;

    // Add MH3 Base rows: nonfoil & land-slot foil only
    function addMH3Base(card){
      const finishes = Array.isArray(card.finishes)? card.finishes : [];
      const rarity = card.rarity;
      const landBasic = isBasic(card);

      // Nonfoil share (normal R/C/U/M + wildcard contributions)
      let pNF = 0;
      if(landBasic){ pNF += pLandNF; }
      else if(rarity==='common'){   pNF += pCommonNF + pWcCommon; }
      else if(rarity==='uncommon'){ pNF += pUncommonNF + pWcUncommon; }
      else if(rarity==='rare'){     pNF += pRslotRare + pWcRare; }
      else if(rarity==='mythic'){   pNF += pRslotMythic + pWcMythic; }

      if(pNF>0 && finishes.includes('nonfoil')){
        pushRow(card,'MH3','normal',PM.point(pNF), priceUSD(card,'normal'), false,false,false);
      }

      // Foil from land slot (for basics only)
      if(landBasic && pLandF>0){
        pushRow(card,'MH3','foil',PM.point(pLandF), priceUSD(card,'foil'), false,false,false);
      }
    }
    mh3Base.forEach(addMH3Base);

    // ===== RETRO (MH3 frame:1997 + H2R) =====
    const retroAll = retroFetched.slice();
    const retroMH3 = retroAll.filter(c => (c.set||'').toLowerCase()==='mh3'); // MH3 retro prints
    const retroH2R = retroAll.filter(c => (c.set||'').toLowerCase()==='h2r'); // Horizons reprints (bonus sheet)

    // Split by rarity, excluding lands
    const filt = (arr,r) => arr.filter(c=>c.rarity===r && !isLand(c));
    const retroMH3_C = filt(retroMH3,'common'),   retroMH3_U = filt(retroMH3,'uncommon'),
          retroMH3_R = filt(retroMH3,'rare'),     retroMH3_M = filt(retroMH3,'mythic');
    const retroH2R_C = filt(retroH2R,'common'),   retroH2R_U = filt(retroH2R,'uncommon'),
          retroH2R_R = filt(retroH2R,'rare'),     retroH2R_M = filt(retroH2R,'mythic');

    // --- Fixed retro shares
    // R/M slot fixed total (2.1%) — apply to MH3 retro R/M only
    if(incRETRO){
      const rmTotal = MH3_ODDS.RETRO_RM_TOTAL;
      const nRM = retroMH3_R.length + retroMH3_M.length || 1;
      const shareR = rmTotal * (retroMH3_R.length / nRM);
      const shareM = rmTotal * (retroMH3_M.length / nRM);
      const perR_RM = retroMH3_R.length ? (shareR / retroMH3_R.length) : 0;
      const perM_RM = retroMH3_M.length ? (shareM / retroMH3_M.length) : 0;
      for(const c of retroMH3_R){ if(perR_RM>0) pushRow(c,'RETRO','retro-R/M', PM.fixed(perR_RM), priceUSD(c,'normal'), false,false,true); }
      for(const c of retroMH3_M){ if(perM_RM>0) pushRow(c,'RETRO','retro-R/M', PM.fixed(perM_RM), priceUSD(c,'normal'), false,false,true); }

      // Wildcard fixed total (4.2%) — split across MH3 retro (all rarities) + H2R (all rarities)
      const wcTotal = MH3_ODDS.RETRO_WC_TOTAL;
      const wcPool = [].concat(retroMH3_C,retroMH3_U,retroMH3_R,retroMH3_M, retroH2R_C,retroH2R_U,retroH2R_R,retroH2R_M);
      const wcN = wcPool.length || 1;
      const perWC = wcTotal / wcN;
      for(const c of wcPool){ pushRow(c,'RETRO','retro-wildcard', PM.fixed(perWC), priceUSD(c,'normal'), false,false,true); }
    }

    // ===== Foil slot: distribute across UNION of base + retro =====
    // Build union pools (exclude basics; foil basics are handled in land slot)
    const unionC = commons.concat(retroMH3_C, retroH2R_C);
    const unionU = uncommons.concat(retroMH3_U, retroH2R_U);
    const unionR = rares.concat(retroMH3_R, retroH2R_R);
    const unionM = mythics.concat(retroMH3_M, retroH2R_M);

    const pFoilC = unionC.length? P.FOIL_C / unionC.length : 0;
    const pFoilU = unionU.length? P.FOIL_U / unionU.length : 0;
    const pFoilR = unionR.length? P.FOIL_R / unionR.length : 0;
    const pFoilM = unionM.length? P.FOIL_M / unionM.length : 0;

    // Add foil rows for base prints (guaranteed foil slot)
    for(const c of commons){   if((c.finishes||[]).includes('foil') && pFoilC>0) pushRow(c,'MH3','foil', PM.point(pFoilC), priceUSD(c,'foil'), false,false,false); }
    for(const c of uncommons){ if((c.finishes||[]).includes('foil') && pFoilU>0) pushRow(c,'MH3','foil', PM.point(pFoilU), priceUSD(c,'foil'), false,false,false); }
    for(const c of rares){     if((c.finishes||[]).includes('foil') && pFoilR>0) pushRow(c,'MH3','foil', PM.point(pFoilR), priceUSD(c,'foil'), false,false,false); }
    for(const c of mythics){   if((c.finishes||[]).includes('foil') && pFoilM>0) pushRow(c,'MH3','foil', PM.point(pFoilM), priceUSD(c,'foil'), false,false,false); }

    // Add foil rows for retro prints (guaranteed foil slot; Special Guests excluded elsewhere)
    const addFoilRetro = (arr, p, tag='RETRO') => { for(const c of arr){ if((c.finishes||[]).includes('foil') && p>0) pushRow(c,tag,'foil', PM.point(p), priceUSD(c,'foil'), false,false,false); } };
    addFoilRetro(retroMH3_C, pFoilC); addFoilRetro(retroH2R_C, pFoilC);
    addFoilRetro(retroMH3_U, pFoilU); addFoilRetro(retroH2R_U, pFoilU);
    addFoilRetro(retroMH3_R, pFoilR); addFoilRetro(retroH2R_R, pFoilR);
    addFoilRetro(retroMH3_M, pFoilM); addFoilRetro(retroH2R_M, pFoilM);

    // ---- Add SPG (MH3 wave only; nonfoil only; ~1/64)
    const pSpg = (spgMH3.length>0) ? (MH3_ODDS.SPG_PER_PACK / spgMH3.length) : 0;
    for(const c of spgMH3){
      if(!(Array.isArray(c.finishes) && c.finishes.includes('nonfoil'))) continue;
      pushRow(c,'SPG','normal',PM.point(pSpg), priceUSD(c,'normal'), false,false,false);
    }

    // ---- Tokens (non‑game slot)
    for(const c of tokAll){
      const usd = priceUSD(c,'normal');
      const usedFallback = !Number.isFinite(usd) && Number.isFinite(tokenFallback);
      const n = Math.max(1, tokAll.length);
      const p = MH3_ODDS.NONGAME_TOKEN / n;
      pushRow(c,'TMH3','normal',PM.point(p), usedFallback? tokenFallback : usd, true, usedFallback, false);
    }

    // ---- Art series (non‑game slot): split normal vs gold‑signed
    const artN = Math.max(1, artAll.length||1);
    for(const c of artAll){
      const cn = String(c.collector_number||'');
      const isSigned = /[A-Za-z]$/.test(cn) && cn.toLowerCase().endsWith('s');
      const usd = priceUSD(c,'normal');
      const usedFallback = !Number.isFinite(usd) && Number.isFinite(artFallback);
      const p = (isSigned ? MH3_ODDS.NONGAME_ART_SIGNED : MH3_ODDS.NONGAME_ART) / artN;
      pushRow(c,'AMH3', isSigned?'signed':'normal', PM.point(p), usedFallback?artFallback:usd, true, usedFallback, false);
    }

    // ===== Normalize playing cards to 14 per pack (reserve fixed first) =====
    const fixedShare = __FIXED_SHARE__;
    const nonFixedMass = __ROW_MODELS__.reduce((s,r)=> s + (!r.nonGame && !r.noScale ? (probPoint(r.model)||0) : 0), 0);
    const target = Math.max(0, 14 - fixedShare);
    __NORM_SCALE__ = nonFixedMass>0 ? (target / nonFixedMass) : 1;

    // Sort rows for display/CSV
    __META_ROWS__.sort((a,b)=>{
      if(a.setTag!==b.setTag) return a.setTag.localeCompare(b.setTag);
      const pa=(a.cn||'').match(/^(\d+)(.*)$/)||[], pb=(b.cn||'').match(/^(\d+)(.*)$/)||[];
      const na=pa[1]?parseInt(pa[1],10):0, nb=pb[1]?parseInt(pb[1],10):0;
      if(na!==nb) return na-nb;
      const sa=pa[2]||'', sb=pb[2]||''; if(sa!==sb) return sa.localeCompare(sb);
      if(a.name!==b.name) return a.name.localeCompare(b.name);
      return a.treatment.localeCompare(b.treatment);
    });

    // CSV
    const header=['Set','Number','Rarity','Name','Treatment','Pack Prob Min (%)','Pack Prob Max (%)','Card Value (USD)','Per 1000 Min','Per 1000 Max','Per 30000 Min','Per 30000 Max','Per 300000 Min','Per 300000 Max'];
    const rows = __META_ROWS__.map((m,idx)=>{
      const r=__ROW_MODELS__[idx];
      const p = probPoint(m.model), pS = (r.nonGame||r.noScale)? p : (p*__NORM_SCALE__);
      const c1k = pS*1000, c30k=pS*30000, c300k=pS*300000;
      return [
        m.setTag, m.cn, m.rarity, m.name, m.treatment,
        (pS*100).toFixed(5)+'%', (pS*100).toFixed(5)+'%',
        fmtUSD(m.price),
        fmtCount(c1k), fmtCount(c1k),
        fmtCount(c30k), fmtCount(c30k),
        fmtCount(c300k), fmtCount(c300k)
      ];
    });
    const csv = rowsToCsv([header,...rows]); window.__CSV__=csv;
    document.getElementById('preview').value=csv.slice(0,300000);
    document.getElementById('downloadCsv').disabled=false;
    document.getElementById('copyCsv').disabled=false;

    // Enable Sift + Purchase EV
    document.getElementById('siftPanel').style.display='';
    document.getElementById('applySift').disabled=false;
    document.getElementById('purchasePanel').style.display='';
    document.getElementById('calcEV').disabled=false;

    // Counts
    const cMH3 = __META_ROWS__.filter(r=>r.setTag==='MH3').length;
    const cRET = __META_ROWS__.filter(r=>r.setTag==='RETRO').length;
    const cSPG = __META_ROWS__.filter(r=>r.setTag==='SPG').length;
    const cTOK = __META_ROWS__.filter(r=>r.setTag==='TMH3').length;
    const cART = __META_ROWS__.filter(r=>r.setTag==='AMH3').length;
    document.getElementById('counts').innerHTML =
      `Built <b>${__META_ROWS__.length.toLocaleString()}</b> rows — MH3: <b>${cMH3}</b>, RETRO: <b>${cRET}</b>, SPG: <b>${cSPG}</b>, TMH3: <b>${cTOK}</b>, AMH3: <b>${cART}</b>. ` +
      `(Retro fixed share reserved: ${(100*fixedShare).toFixed(2)}%; normalization factor: ${__NORM_SCALE__.toFixed(5)})`;

    document.getElementById('status').textContent = `Done. Reserved retro shares (R/M 2.1% + Wildcard 4.2%); scaled remaining to 14 cards/pack.`;

    // Auto-apply Sift and initial EV render
    applySift(parseUSD(document.getElementById('siftMin').value) ?? 0.25);
    renderPurchaseEV();
    renderTotalsTable();
    document.getElementById('totalsPanel').style.display='';
    if(det) det.open=false;

  }catch(err){
    console.error(err);
    document.getElementById('status').textContent='Error while building — see details below.';
    document.getElementById('errorMsg').innerHTML = `<strong>Set:</strong> ${err?.set||'Unknown'} &nbsp; <strong>Status:</strong> ${err?.status??'ERROR'}`;
    document.getElementById('errorDetails').textContent = `Query:\n${err?.query||'(no query)'}\n\nResponse snippet:\n${String(err?.details||'').slice(0,800)}`;
    document.getElementById('errorBox').style.display='';
    document.getElementById('downloadCsv').disabled=true;
    document.getElementById('copyCsv').disabled=true;
    document.getElementById('applySift').disabled=true;
    document.getElementById('downloadSiftCsv').disabled=true;
    document.getElementById('calcEV').disabled=true;
  }
}

/* ========================= Sift table ========================= */
function renderSiftTable(minUSD){
  const body=document.getElementById('siftBody'); body.innerHTML='';
  for(let i=0;i<__META_ROWS__.length;i++){
    const m=__META_ROWS__[i], r=__ROW_MODELS__[i];
    const ok = Number.isFinite(m.price) && m.price>=minUSD;
    const cls = ok ? 'sift-ok' : 'sift-bad';
    const p = probPoint(m.model), pS = (r.nonGame||r.noScale) ? p : (p*__NORM_SCALE__);
    const c1k=pS*1000, c30k=pS*30000, c300k=pS*300000;

    const tr=document.createElement('tr'); tr.className=cls;
    const cells=[ m.setTag, m.cn, m.rarity, /* name link */, m.treatment,
      (pS*100).toFixed(5)+'%', (pS*100).toFixed(5)+'%', fmtUSD(m.price),
      fmtCount(c1k), fmtCount(c1k), fmtCount(c30k), fmtCount(c30k), fmtCount(c300k), fmtCount(c300k)
    ];
    let td=document.createElement('td'); td.textContent=cells[0]; tr.appendChild(td);
    td=document.createElement('td'); td.textContent=cells[1]; tr.appendChild(td);
    td=document.createElement('td'); td.textContent=cells[2]; tr.appendChild(td);
    td=document.createElement('td');
      if(m.url){ const a=document.createElement('a'); a.href=m.url; a.target='_blank'; a.rel='noopener noreferrer'; a.textContent=m.name; td.appendChild(a); }
      else td.textContent=m.name;
    tr.appendChild(td);
    td=document.createElement('td'); td.textContent=cells[4]; tr.appendChild(td);
    for(let j=5;j<cells.length;j++){ const x=document.createElement('td'); x.textContent=cells[j]; tr.appendChild(x); }
    body.appendChild(tr);
  }
  document.getElementById('siftTableWrap').style.display='';

  // Summary
  const P=300000; let include=0,exclude=0,missing=0;
  for(let i=0;i<__ROW_MODELS__.length;i++){
    const r=__ROW_MODELS__[i];
    const p=probPoint(r.model), pS=(r.nonGame||r.noScale)? p : (p*__NORM_SCALE__);
    const ok = Number.isFinite(r.price) && r.price >= minUSD;
    if(ok){ include++; } else { exclude++; if(!Number.isFinite(r.price)) missing++; }
  }
  document.getElementById('siftSummary').innerHTML = `Sift ≥ <b>$${Number(minUSD).toFixed(2)}</b> — Included: <b>${include.toLocaleString()}</b> / Excluded: <b>${exclude.toLocaleString()}</b>` + (missing? ` (no USD on ${missing})`:``);
}
function applySift(minUSD){
  renderSiftTable(minUSD);
  const header=['Set','Number','Rarity','Name','Treatment','Pack Prob Min (%)','Pack Prob Max (%)','Card Value (USD)','Per 1000 Min','Per 1000 Max','Per 30000 Min','Per 30000 Max','Per 300000 Min','Per 300000 Max'];
  const rows=[], tbody=document.getElementById('siftBody');
  for(const tr of tbody.querySelectorAll('tr')) rows.push(Array.from(tr.querySelectorAll('td')).map(td=>td.textContent));
  __SIFT_CSV__ = rowsToCsv([header,...rows]);
  document.getElementById('downloadSiftCsv').disabled=false;
}

/* ==================== Purchase EV & Totals ==================== */
function statRange(packs, useSift, minUSD){
  let meanPerPack=0, varPerPack=0, missingPrice=0;
  for(const row of __ROW_MODELS__){
    const p = probPoint(row.model), pS = (row.nonGame||row.noScale)? p : (p*__NORM_SCALE__);
    const usd=row.price;
    if(useSift && !(Number.isFinite(usd) && usd>=minUSD)) continue;
    if(!Number.isFinite(usd)){ missingPrice++; continue; }
    meanPerPack += pS * usd;
    varPerPack  += pS * (1 - pS) * usd * usd;
  }
  const mean = meanPerPack * packs;
  const sd   = Math.sqrt(Math.max(0, varPerPack * packs));
  return { mean, sd, missingPrice };
}

function renderPurchaseEV(){
  const boxes=Math.max(0, parseFloat(document.getElementById('boxesToBuy').value)||0);
  const packs=boxes*PACKS_PER_BOX;
  const useSift=document.getElementById('useSiftForEV').checked;
  const minUSD=parseUSD(document.getElementById('siftMin').value) ?? 0.25;
  const mode=(document.querySelector('input[name="rangeMode"]:checked')||{}).value || 'stat';
  const conf=parseFloat(document.getElementById('confLevel').value)||95;
  const z=zFromConf(conf);

  let lowEV,estEV,highEV,tag,missing='';
  if(mode==='struct'){
    // Slot model point EV
    let est=0, miss=0;
    for(const row of __ROW_MODELS__){
      const p=probPoint(row.model), pS=(row.nonGame||row.noScale)? p : (p*__NORM_SCALE__);
      if(!Number.isFinite(pS)) continue;
      const usd=row.price;
      if(useSift && !(Number.isFinite(usd)&&usd>=minUSD)) continue;
      if(!Number.isFinite(usd)){ miss++; continue; }
      est += usd * pS * packs;
    }
    lowEV=est; estEV=est; highEV=est; tag='Structural model (slot mix)';
    if(miss>0) missing = `${miss} rows had no USD price and were excluded.`;
  }else{
    const {mean,sd,missingPrice} = statRange(packs,useSift,minUSD);
    estEV=mean; lowEV=Math.max(0, mean - z*sd); highEV=mean + z*sd; tag=`Statistical ${conf}% interval (CLT)`;
    if(missingPrice>0) missing = `${missingPrice} rows had no USD price and were excluded.`;
  }

  const perBoxLow  = boxes>0 ? lowEV/boxes : 0;
  const perBoxEst  = boxes>0 ? estEV/boxes : 0;
  const perBoxHigh = boxes>0 ? highEV/boxes : 0;

  const evDiv=document.getElementById('purchaseEVContainer');
  evDiv.innerHTML = `
    <table>
      <thead><tr><th>Metric</th><th>Low</th><th>Est.</th><th>High</th></tr></thead>
      <tbody>
        <tr><td>${tag} — across ${packs.toLocaleString()} packs</td><td>$${money(lowEV)}</td><td>$${money(estEV)}</td><td>$${money(highEV)}</td></tr>
        <tr><td>${PACKS_PER_BOX}-pack box</td><td>$${money(perBoxLow)}</td><td>$${money(perBoxEst)}</td><td>$${money(perBoxHigh)}</td></tr>
      </tbody>
    </table>`;
  evDiv.style.display='';

  const notes=[];
  notes.push(`Boxes: ${boxes.toLocaleString()} × ${PACKS_PER_BOX} = ${packs.toLocaleString()} packs.`);
  notes.push(`Using ${useSift ? `Sift ≥ $${(Number.isFinite(minUSD)?minUSD:0.25).toFixed(2)}` : 'all prints'}.`);
  if(mode==='stat') notes.push('Variance method: Σ p·(1−p)·value² per pack (independence approximation).');
  if(missing) notes.push(missing);
  document.getElementById('purchaseSummary').textContent=notes.join(' ');

  document.getElementById('rangeNotes').textContent = (mode==='struct')
    ? 'Structural range reflects slot‑mix assumptions; scales ~linearly with packs.'
    : 'Statistical range reflects random pull variance; narrows ~1/√n with more boxes.';

  renderTotalsTable();
}

function renderTotalsTable(){
  const boxes=Math.max(0, parseFloat(document.getElementById('boxesToBuy').value)||0);
  if(boxes<=0){ document.getElementById('totalsPanel').style.display='none'; return; }
  const P = boxes * PACKS_PER_BOX;

  let estCount=0, estEV=0, missingPrice=0, fallbackUsed=0;
  for(const row of __ROW_MODELS__){
    const p = probPoint(row.model), pS = (row.nonGame||row.noScale)? p : (p*__NORM_SCALE__);
    estCount += pS * P;
    const usd=row.price;
    if(Number.isFinite(usd)) estEV += usd * pS * P; else missingPrice++;
    if(row.fallback) fallbackUsed++;
  }

  const perBoxEst = boxes>0 ? estEV/boxes : 0;

  const body=document.getElementById('totalsBody');
  body.innerHTML = `
    <tr><td>Total expected items @ ${P.toLocaleString()} packs (14 cards + 1 non‑game)</td>
        <td>${fmtInt(P*15)}</td><td>${fmtInt(P*15)}</td><td>${fmtInt(P*15)}</td></tr>
    <tr><td>…of which non‑game (token/art)</td>
        <td>${fmtInt(P*1)}</td><td>${fmtInt(P*1)}</td><td>${fmtInt(P*1)}</td></tr>
    <tr><td>…of which playing cards (normalized; retro fixed reserved)</td>
        <td>${fmtInt(P*14)}</td><td>${fmtInt(P*14)}</td><td>${fmtInt(P*14)}</td></tr>
    <tr><td>Total EV across ${P.toLocaleString()} packs</td>
        <td>$${money(estEV)}</td><td>$${money(estEV)}</td><td>$${money(estEV)}</td></tr>
    <tr><td>EV per ${PACKS_PER_BOX}-pack box (${boxes.toLocaleString()} boxes)</td>
        <td>$${money(perBoxEst)}</td><td>$${money(perBoxEst)}</td><td>$${money(perBoxEst)}</td></tr>
  `;

  const notes=[];
  if(missingPrice>0) notes.push(`${missingPrice} rows had no USD price (fallbacks used where provided).`);
  if(fallbackUsed>0) notes.push(`${fallbackUsed} token/art rows used fallback values.`);
  if(__FIXED_SHARE__>0) notes.push(`Retro fixed share reserved: ${(100*__FIXED_SHARE__).toFixed(2)}% of playing cards (R/M 2.1% + Wildcard 4.2%).`);
  notes.push('Remaining playing‑card probabilities are scaled to sum to 14 per pack; non‑game slot uses 65%/30%/5%.');
  document.getElementById('totalsNotes').textContent = 'Notes: ' + notes.join(' ');

  document.getElementById('totalsPanel').style.display='';
}

/* ============================ CSV helpers ============================ */
function rowsToCsv(rows){
  return rows.map(r => r.map(v=>{ const s=String(v??''); return /[",\n]/.test(s)? '"'+s.replace(/"/g,'""')+'"' : s; }).join(',')).join('\n');
}

/* ============================== Hooks ============================== */
document.getElementById('buildBtn').addEventListener('click', build);
document.getElementById('downloadCsv').addEventListener('click', ()=>{ if(window.__CSV__){
  const blob=new Blob(["\uFEFF"+window.__CSV__],{type:'text/csv;charset=utf-8'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='MH3_PlayBooster_List.csv';
  document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
}});
document.getElementById('copyCsv').addEventListener('click', async ()=>{
  if(!window.__CSV__) return;
  try{ await navigator.clipboard.writeText(window.__CSV__); alert('CSV copied to clipboard.'); }
  catch{ const t=document.getElementById('preview'); t.focus(); t.select(); alert('Select all (Ctrl/Cmd+A) and copy (Ctrl/Cmd+C).'); }
});
document.getElementById('applySift').addEventListener('click', ()=>{
  applySift(parseUSD(document.getElementById('siftMin').value) || 0.25);
});
document.getElementById('calcEV').addEventListener('click', renderPurchaseEV);
document.getElementById('boxesToBuy').addEventListener('change', ()=>{ renderPurchaseEV(); renderTotalsTable(); });
document.getElementById('useSiftForEV').addEventListener('change', renderPurchaseEV);
document.getElementById('siftMin').addEventListener('change', ()=>{ applySift(parseUSD(document.getElementById('siftMin').value) || 0.25); renderPurchaseEV(); });
document.getElementById('confLevel').addEventListener('change', renderPurchaseEV);
for(const r of document.querySelectorAll('input[name="rangeMode"]')) r.addEventListener('change', renderPurchaseEV);

// Auto‑build
window.addEventListener('DOMContentLoaded', build);
</script>

<!-- Clamp Sift to $0.01 (works when 0, negative, blank, NaN) -->
<script>
(function(){
  function clampSiftMin(){
    const el = document.getElementById('siftMin');
    if(!el) return 0.01;
    let v = parseFloat(String(el.value).replace(/[^0-9.]/g,'')); if(!Number.isFinite(v) || v <= 0) v = 0.01;
    el.value = v.toFixed(2);
    return v;
  }
  window.getSiftMinClamped = clampSiftMin;
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', clampSiftMin, { once:true }); else clampSiftMin();
  document.addEventListener('click', function(e){
    const id=e.target && e.target.id; if(id==='applySift' || id==='calcEV') clampSiftMin();
  }, true);
  document.getElementById('siftMin')?.addEventListener('change', clampSiftMin, true);
})();
</script>
</body>
</html>
